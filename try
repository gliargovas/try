#!/bin/sh

usage() {
    cmd="$(basename $0)"
    cat >&2 <<EOF
Usage: $cmd [-n] [-D DIR] CMD [ARG ...]

  -n                don't prompt for commit
  -D DIR            work in DIR (implies -n)

Subcommands:
  $cmd summary DIR   show the summary for the overlay in DIR
  $cmd commit DIR    commit the overlay in DIR
EOF
    exit 2
}

NO_COMMIT=0

while getopts ":n:D" opt
do
    case "$opt" in
        (n) NO_COMMIT=1;;
        (D) if ! [ -d "$OPTARG" ]
            then
                printf "%s: no such directory $OPTARG\n" "$(basename $)" >&2
                exit 2
            fi
            SANDBOX_DIR="$OPTARG"
            NO_COMMIT=1
            ;;
        (h|*) usage;;
    esac
done

shift $(($OPTIND - 1))

if [ "$#" -eq 0 ]
then
    usage
fi

START_DIR="$PWD"

[ "$SANDBOX_DIR" ] || SANDBOX_DIR=$(mktemp -d)
mkdir -p "$SANDBOX_DIR/upperdir" "$SANDBOX_DIR/workdir" "$SANDBOX_DIR/temproot"

# we will overlay-mount each root directory separately (instead of all at once) because some directories cannot be overlayed
# so we set up the mount points now
#
# TODO can we avoid warnings?
# TODO can we make this more uniform?
ls / | xargs -I '{}' mkdir "$SANDBOX_DIR"/temproot/'{}' "$SANDBOX_DIR"/workdir/'{}' "$SANDBOX_DIR"/upperdir/'{}'

mount_and_execute=$(mktemp)
chroot_executable=$(mktemp)
cat >"$mount_and_execute" <<EOF
#!/bin/sh

# actually mount the overlays
# TODO we may not need to ignore ALL of these (paltform dependent?)
ls / | grep -v -e proc -e dev -e proj -e run -e sys -e snap -e swap.img | xargs -I '{}' mount -t overlay overlay -o lowerdir=/'{}',upperdir="$SANDBOX_DIR"/upperdir/'{}',workdir="$SANDBOX_DIR"/workdir/'{}' "$SANDBOX_DIR"/temproot/'{}'

unshare --root="$SANDBOX_DIR/temproot" /bin/bash "$chroot_executable" 
EOF

cat >"$chroot_executable" <<EOF
#!/bin/sh

mount -t proc proc /proc &&
cd $START_DIR && 
exec $@
EOF

echo
cat $mount_and_execute
echo
cat $chroot_executable

chmod +x "$mount_and_execute" "$chroot_executable"

# --mount: mounting and unmounting filesystems will not affect the rest of the system inside the unshare
# --map-root-user: map to the superuser UID and GID in the newly created user namespace.
# --user: the process will have a distinct set of UIDs, GIDs and capabilities.
# --pid: create a new process namespace (needed fr procfs to work right)
# --fork: necessary if we do --pid
#         "Creation of a persistent PID namespace will fail if the --fork option is not also specified."
unshare --mount --map-root-user --user --pid --fork "$mount_and_execute"
